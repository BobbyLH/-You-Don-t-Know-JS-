# 词法作用域(Lexical Scope)
编程语言中，和 *作用域* 有关的模型一般分为：
- 词法作用域(Lexical Scope)

- 动态作用域(Dynamic Scope)

前者是本章重点讲述的内容，后者会在附录A中呈现。

## Lex-time
之前一章提到过，*编译器* 在编译阶段第一件事就是做词法分析(lexing / tokenizing)。在这个过程中产生了 *词法作用域*，换句话说，*词法作用域* 是基于你书写代码(变量和块)时就已经确定的，静态的作用域。

**Note**：虽然JS中有一些方法能够动态的修改 *词法作用域*，但这些方法非常危险；对于 *词法作用域* 最佳实践是保持原汁原味 —— 代码写(编译)的时候是什么样就是什么样。

```javascript
function foo (a) {
  var b = a * 2;
  
  function bar (c) {
    console.log(a, b, c);
  };

  bar (b * 3);
};

foo (2); // 2 4 12
```
👆上面代码有三个嵌套的作用域：
1. 全局作用域，这个作用域中能访问到函数 `foo`；

2. 函数 `foo` 的作用域，这个作用域能访问变量 `b`、参数 `a`、函数`bar`，以及外层的全局作用域；

3. 函数 `bar` 的作用域，该作用域能访问参数 `c`，以及外层的 `bar` 作用域能访问的内容。

可以看出，这些作用域是在代码书写时就确定的。

### 查询(Look-ups)
**作用域查找会在找到第一个满足的值后停止(Scope look-up stops once it finds the first match)**。如果 *不同层级的作用域* 存在同名的变量，就会产生 *遮盖(shadowing)* —— 内部的变量会 *遮挡(shadow)* 外层的变量。

`window.a` 可以避免全局变量 `a` 被 *遮挡* 的情况：
```javascript
var a = 5;
function foo () {
  var a = 6;
  console.log(window.a);
};

foo(); // 5
```

无论函数在何处被调用、如何调用，*词法作用域* 仅会在函数声明的时候定义。

## 欺骗作用域(Cheating Lexical)
JS中有两个机制能够在运行的过程中，动态的“欺骗”作用域：`eval` 和 `with`。

社区内普遍认为这是两个应该被弃绝的东西，因为它不仅让你的代码难以维护，更重要的是，它们会严重的影响性能！

### `eval`
`eval(…)` 接受字符串作为参数，并将这些字符串作为可执行的程序执行。这意味着，你能够在编写 *由程序本身生成的代码*。

从这个角度来看，`eval` 能让你 *欺骗词法作用域*，让它以为这段代码是在你写的(实际上你确实写了，只不过它是一个字符串，然后在代码运行的时候由程序生成了可执行的代码)。

```javascript
function foo (str, a) {
  eval(str);
  console.log(a, b);
};

var b = 2;
foo('var b = 3;', 1); // 1, 3
```
👆`'var b = 3;'` 作为字符串传递到 `eval` 中，然后生成并执行了这段代码；在随后的 `console.log(a, b);` 中，对于 RHS `b` 的查询在函数 `foo` 的作用域内就完成了，直接无视了全局作用域中声明的 `var b = 2;`。

`eval` 的本质是用来动态创建代码，但带来的 *副作用* 就是也同时能修改在 *代码写作时(author-time)* 确定的 *词法作用域*。

在严格模式中，`eval` 不能修改作用域：
```javascript
function foo (str) {
  "use strict";
  eval(str);
  console.log(a);
};

var a = 2;
foo('var a = 3;'); // 2
```

除了 `eval` 之外，`setTimeout` 和 `setInterval` 的第一个参数也能接受一个字符串，并随后动态的生成执行的回调函数 —— 这是一个古老的特性，别用它！

另外，构造函数 `new Function(…)` 的最后一个参数也能接受字符串，并动态生成函数 —— 别用它！

动态生成代码在实际生产中的用处不太大，并且由于带来的性能问题，弊大于利！

### `with`