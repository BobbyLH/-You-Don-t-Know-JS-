# 什么是作用域?(What is Scope?)
几乎所有的编程语言都有能够 *在变量中保存值并能将值取回* 的基本范式(fundamental prardigms)。

关于这些能够储存值的变量，最有意思的问题是：这些变量本身保存在什么地方？当我们想要从中取回值时，我们的程序又是如何找到它们的？

**作用域(Scope)** 就是我们抽象的一个概念，它指代存储和查询变量的一些列定义明确的规则。

## 编译原理(Compiler Theory)
JS虽然被归为 *动态的(dynamic)*、*解释的(interpreted)* 语言，但实际上它是 *编译型(compiled)* 语言 —— 即便是它没有像其他语言一样被提前编译好，更不能将编译的结果移植和复用 —— 传统的编译代码的步骤，JS引擎同样会经历：
1. **打标记(Tokenizing) / 词法分析(Lexing)**：将字符串代码拆分成有意义的串，比如将 `var a = 2;` 拆成 `var`、`a`、`=`、`2`、`;`。*空格(whitespace)* 不一定会被打标记，这取决于这个它是否有意义；

  **Note**：*tokenizing* 和 *lexing* 的有一些微妙和学术上的区别，但核心是 *token* 会鉴别有无状态。简单来讲，如果 *标记器(tokenizer)* 调用有状态的解析规则判断 `a` 到底是独立的 *token* 还是另一个 *token* 的一部分时，这叫 *词法分析(lexing)*。

2. **解析(Parsing)**：获取到 *流式的(stream)* 或 *阵列(array)* 的 *标记(tokens)*，并转换成树状嵌套结构的元素 —— 即代表一种语法的数据结构 —— 这样的树被称为 **AST 抽象语法树(Abstract Syntax Tree)**。

3. **生成代码(Code-Generation)**：这是一个将 *AST* 转换成 *可执行代码(excutable code)* 的一个过程；这个过程会根据不同的语言、不同的目标平台而有不一样的变化。

  因此在这里，我们简单的理解这个过程：拿到关于 `var a = 2;` 的 *AST* 后，将其转换成机器指令，并创建一个变量 `a` 和其内存，然后将值 `2` 存储至其中。

JS引擎执行编译的过程远比👆上面的步骤要复杂。比如，在生产代码阶段，有好几种需要优化性能的操作，包括压缩冗余的元素(collapsing redundant elements)等等……

同时，JS引擎的编译时长是很短的，几乎只有几 *微秒(microseconds)* 的时长，因为它不会做提前编译，因此JS引擎用了一些其他的手段来确保性能，比如 *JITs*。

## 作用域详解(Understanding Scope)
### 演员表(The Cast)
关于执行 `var a = 2;` 的演员阵容如下：

1. *引擎(Engine)*：负责从头到尾的编译和执行JS程序；

2. *编译器(Compiler)*：引擎的一个朋友，负责处理打标记、解析和生成代码的脏活累活；

3. *作用域(Scope)*：引擎的另一个朋友，收集和维护一个关于所有已声明变量的查询列表，并且会对当前的代码可访问性执行一套严格的规则。

理解JS是如何运行的关键是像 *JS引擎一样去思考* —— 提出引擎所要提的问题，并且做出相应的回答。

### 回合(Back & Forth)
当JS引擎发现 `var a = 2;` 这段代码时，它会将其分解成两部分：一部分是 *编译器* 在编译阶段负责的；另一部分是 *JS引擎* 自己在代码执行阶段需要处理的。

其中 *编译器* 工作的过程如下：
1. 做词法分析，将 `var a = 2;` 拆分成各种 *token*，而后将其解析成 *抽象语法树*；

2. 生产代码的过程稍微有点复杂：
  - 当遇到 `var a` 时，*编译器* 会询问 *作用域* 变量 `a` 是否在这个指定的作用域集合内已经存在；如果存在，*编译器* 会跳过 *声明(declaration)* 动作；否则，*编译器* 会要求 *作用域* 在这个作用域内声明一个新的变量。

  - *编译器* 生成了 `a = 2` 提供给 *JS引擎* 去执行，*JS引擎* 执行到这段代码时，也会先问 *作用域* 变量 `a` 在当前的作用域中是否能访问；如果可以，*JS引擎* 就会使用这个变量完成 _赋值(assignment)_ 的动作；如果不行，*JS引擎* 则会去询问别处的 *作用域*。若是最终 *JS引擎* 没有找到这个变量，就会报错。

  总结👆变量赋值操作两点：第一，*编译器* 负责声明变量；第二，*JS引擎* 查找并绑定变量(如果找到的话)。它们都需要和 *作用域* 进行交互。

### 编译器的内心独白(Compiler Speak)


