# 什么是作用域?(What is Scope?)
几乎所有的编程语言都有能够 *在变量中保存值并能将值取回* 的基本范式(fundamental prardigms)。

关于这些能够储存值的变量，最有意思的问题是：这些变量本身保存在什么地方？当我们想要从中取回值时，我们的程序又是如何找到它们的？

**作用域(Scope)** 就是我们抽象的一个概念，它指代存储和查询变量的一些列定义明确的规则。

## 编译原理(Compiler Theory)
JS虽然被归为 *动态的(dynamic)*、*解释的(interpreted)* 语言，但实际上它是 *编译型(compiled)* 语言 —— 即便是它没有像其他语言一样被提前编译好，更不能将编译的结果移植和复用 —— 传统的编译代码的步骤，JS引擎同样会经历：
1. **打标记(Tokenizing) / 词法分析(Lexing)**：将字符串代码拆分成有意义的串，比如将 `var a = 2;` 拆成 `var`、`a`、`=`、`2`、`;`。*空格(whitespace)* 不一定会被打标记，这取决于这个它是否有意义；

**Note**：*tokenizing* 和 *lexing* 的有一些微妙和学术上的区别，但核心是 *token* 会鉴别有无状态。简单来讲，如果 *标记器(tokenizer)* 调用有状态的解析规则判断 `a` 到底是独立的 *token* 还是另一个 *token* 的一部分时，这叫 *词法分析(lexing)*。

2. **解析(Parsing)**：获取到 *流式的(stream)* 或 *阵列(array)* 的 *标记(tokens)*，并转换成树状嵌套结构的元素 —— 即代表一种语法的数据结构 —— 这样的树被称为 **AST 抽象语法树(Abstract Syntax Tree)**。

3. **生成代码(Code-Generation)**：这是一个将 *AST* 转换成 *可执行代码(excutable code)* 的一个过程；这个过程会根据不同的语言、不同的目标平台而有不一样的变化。

因此在这里，我们简单的理解这个过程：拿到关于 `var a = 2;` 的 *AST* 后，将其转换成机器指令，并创建一个变量 `a` 和其内存，然后将值 `2` 存储至其中。

JS引擎执行编译的过程远比👆上面的步骤要复杂。比如，在生产代码阶段，有好几种需要优化性能的操作，包括压缩冗余的元素(collapsing redundant elements)等等……

同时，JS引擎的编译时长是很短的，几乎只有几 *微秒(microseconds)* 的时长，因为它不会做提前编译，因此JS引擎用了一些其他的手段来确保性能，比如 *JITs*。

## 作用域详解(Understanding Scope)