# 什么是作用域?(What is Scope?)
几乎所有的编程语言都有能够 *在变量中保存值并能将值取回* 的基本范式(fundamental prardigms)。

关于这些能够储存值的变量，最有意思的问题是：这些变量本身保存在什么地方？当我们想要从中取回值时，我们的程序又是如何找到它们的？

**作用域(Scope)** 就是我们抽象的一个概念，它指代存储和查询变量的一些列定义明确的规则。

## 编译原理(Compiler Theory)
JS虽然被归为 *动态的(dynamic)*、*解释的(interpreted)* 语言，但实际上它是 *编译型(compiled)* 语言 —— 即便是它没有像其他语言一样被提前编译好，更不能将编译的结果移植和复用 —— 传统的编译代码的步骤，JS引擎同样会经历：
1. **打标记(Tokenizing) / 词法分析(Lexing)**：将字符串代码拆分成有意义的串，比如将 `var a = 2;` 拆成 `var`、`a`、`=`、`2`、`;`。*空格(whitespace)* 不一定会被打标记，这取决于这个它是否有意义；

  **Note**：*tokenizing* 和 *lexing* 的有一些微妙和学术上的区别，但核心是 *token* 会鉴别有无状态。简单来讲，如果 *标记器(tokenizer)* 调用有状态的解析规则判断 `a` 到底是独立的 *token* 还是另一个 *token* 的一部分时，这叫 *词法分析(lexing)*。

2. **解析(Parsing)**：获取到 *流式的(stream)* 或 *阵列(array)* 的 *标记(tokens)*，并转换成树状嵌套结构的元素 —— 即代表一种语法的数据结构 —— 这样的树被称为 **AST 抽象语法树(Abstract Syntax Tree)**。

3. **生成代码(Code-Generation)**：这是一个将 *AST* 转换成 *可执行代码(excutable code)* 的一个过程；这个过程会根据不同的语言、不同的目标平台而有不一样的变化。

  因此在这里，我们简单的理解这个过程：拿到关于 `var a = 2;` 的 *AST* 后，将其转换成机器指令，并创建一个变量 `a` 和其内存，然后将值 `2` 存储至其中。

JS引擎执行编译的过程远比👆上面的步骤要复杂。比如，在生产代码阶段，有好几种需要优化性能的操作，包括压缩冗余的元素(collapsing redundant elements)等等……

同时，JS引擎的编译时长是很短的，几乎只有几 *微秒(microseconds)* 的时长，因为它不会做提前编译，因此JS引擎用了一些其他的手段来确保性能，比如 *JITs*。

## 作用域详解(Understanding Scope)
### 演员表(The Cast)
关于执行 `var a = 2;` 的演员阵容如下：

1. *引擎(Engine)*：负责从头到尾的编译和执行JS程序；

2. *编译器(Compiler)*：引擎的一个朋友，负责处理打标记、解析和生成代码的脏活累活；

3. *作用域(Scope)*：引擎的另一个朋友，收集和维护一个关于所有已声明变量的查询列表，并且会对当前的代码可访问性执行一套严格的规则。

理解JS是如何运行的关键是像 *JS引擎一样去思考* —— 提出引擎所要提的问题，并且做出相应的回答。

### 回合(Back & Forth)
当JS引擎发现 `var a = 2;` 这段代码时，它会将其分解成两部分：一部分是 *编译器* 在编译阶段负责的；另一部分是 *JS引擎* 自己在代码执行阶段需要处理的。

其中 *编译器* 工作的过程如下：
1. 做词法分析，将 `var a = 2;` 拆分成各种 *token*，而后将其解析成 *抽象语法树*；

2. 生产代码的过程稍微有点复杂：
  - 当遇到 `var a` 时，*编译器* 会询问 *作用域* 变量 `a` 是否在这个指定的作用域集合内已经存在；如果存在，*编译器* 会跳过 *声明(declaration)* 动作；否则，*编译器* 会要求 *作用域* 在这个作用域内声明一个新的变量。

  - *编译器* 生成了 `a = 2` 提供给 *JS引擎* 去执行，*JS引擎* 执行到这段代码时，也会先问 *作用域* 变量 `a` 在当前的作用域中是否能访问；如果可以，*JS引擎* 就会使用这个变量完成 _赋值(assignment)_ 的动作；如果不行，*JS引擎* 则会去询问别处的 *作用域*。若是最终 *JS引擎* 没有找到这个变量，就会报错。

  总结👆变量赋值操作两点：第一，*编译器* 负责声明变量；第二，*JS引擎* 查找并绑定变量(如果找到的话)。它们都需要和 *作用域* 进行交互。

### 编译器的内心独白(Compiler Speak)
在生产代码过程中，*编译器* 询问 *作用域* 某个变量存在与否时，不同类型的查找方式(look-up)会影响最后的结果。

在 `var a = 2;` 这个🌰中，执行的是 **左侧LHS(Left-hand Side)** 模式，与之对应的是 **右侧RHS(Right-hand Side)**模式。

**Note**：所谓的 *Side*，即意味着在 **赋值操作符(assignment operation)** 即 `=` 的哪一侧。

*LHS* 的 *查询(look-up)* 动作完成于变量出现在 **赋值操作符** 的左侧，但对应的 *RHS*，并**不是**代表变量出现在赋值操作符的右侧，而是任何非 *LHS* 就是 *RHS*。

*RHS* 有时候是难以区分的，但简单而言，就是 *从变量处取出其保存的值*；而 *LHS* 则是 *找到变量自身*，而非关注它保存的值：

```javascript
console.log(a);
```
👆这里的查询的操作 `a` 就是属于 *RHS*，在这个表达式中，我们只关心 `a` 的值；

```javascript
a = 2;
```
👆这里的查询的赋值操作是 *LHS* —— 我们一点也不关心现在 `a` 的值，我们只想找到变量 `a`，然后把 `2` 赋值给它；

```javascript
function foo (a) {
  console.log(a); // 2
};

foo(2);
```
- 👆最后一行 `foo(2);` 属于 *RHS* —— 关心的是从 `foo` 中取值；

- 👆在函数 `foo` 内部，有一个隐式的赋值操作 —— 将参数 `2` 赋值给函数内部变量 `a`，这是 *LHS*；

- 👆在函数内部的表达式 `console.log(a)` 中查询 `a` 和上面讨论的一样，是 *RHS*，从 `console` 对象中取值 `log` 同样也是 *RHS* —— 查询是否有 `log` 方法，并取出其值。最终，在内建的 `log(…)` 方法内部，也是先进行了 *LHS* 的操作将 `a` 的值进行了隐式的赋值操作。

- *编译器* 在生成代码阶段，进行 *声明(declaration)* 和 *值定义(value definition)* 的时候有重要的区别。对于函数声明 `function foo` 并非是我们所讨论的 *LHS* 的模式，除非是 `var foo = function () {};` 这样的值定义才属于 *LHS*。

### 引擎和作用域之间的交谈(Engine/Scope Conversation)
```javascript
function foo (a) {
  console.log(a); // 2
};

foo(2);
```
依然用👆这个例子，不过这一次是用对白的方式进行：
> JS引擎：*作用域*，我这里有一个 RHS 叫 `foo`，你知道它存在么？
> 作用域：我知道，刚不久 *编译器* 这家伙声明的，它是一个函数，给你…
> JS引擎：感谢！那我要开始执行 `foo` 了，先把 `2` 作为参数传进去…
> JS引擎：哦对了，*作用域*，我这边还有一个 LHS 叫 `a` 需要进行赋值操作，你知道它么？
> 作用域：我知道，刚不久 *编译器* 这家伙声明 `foo` 的时候也把这个参数给声明了，拿走不谢…
> JS引擎：太好了，再次感谢！那我现在就把 `2` 赋值给 `a`…
> JS引擎：*作用域*，再次叨扰一番：我目前需要一个 RHS 是关于 `console` 的，你知道它么？
> 作用域：别客气，这是我本职工作，我拿到 `console` 了，它是一个内置对象，拿去吧…
> JS引擎：完美，现在我要从这个对象中找一个 `log`，它是个函数，棒极了！
> JS引擎：嘿，*作用域*，你能帮我查询一个 RHS 叫 `a` 么？我虽然记得它，但还是想要再次确认一番…
> 作用域：没问题 *引擎*…它还是和之前一模一样，没变化，拿走…
> JS引擎：帅呆了！那现在我就把 `a` 的值 `2`，传入到 `log(…)` 中…

### 小测验(Quiz)
```javascript
function foo (a) {
  var b = a;
  return a + b;
};

var c = foo(2);
```
1. 识别出所有的 *LHS* (一共有3个)；
   <details>
   <summary>先自己想一想</summary>

   - 将 `foo` 调用的返回值赋值给 `c`；

   - 将 `2` 赋值给函数参数 `a`；

   - 将参数 `a` 赋值给 `foo` 内部的变量 `b`。
   </details>


2. 识别出所有的 *RHS* (一共有4个)；
   <details>
   <summary>先自己想一想</summary>

   - 调用函数 `foo(…)`；

   - 将参数 `a` 取值赋值给变量 `b`；

   - 在 `+` 操作中，取值参数 `a`

   - 在 `+` 操作中，取值变量 `b`
   </details>


## 嵌套作用域(Nested Scope)
之前提到，*作用域* 就是一组 **通过变量名查找变量** 的规则的集合。通常 *作用域* 远不止一个。

就和函数嵌套函数一样，作用域也能嵌套作用域。如果一个变量在当前作用域中不存在，那么 *JS引擎* 就会询问外层的作用域，直到找到这个变量或者到达最外层的作用域，即全局(global)作用域。

```javascript
function foo (a) {
  console.log(a + b);
};

var b = 2;

foo(2); // 4
```
在函数 `foo` 中的作用域👆，未能查询到RHS `b`，但在全局作用域有解，如果模拟 *JS引擎* 和 *作用域* 之间的对白：
> JS引擎：*作用域*`foo`，你知道变量 `b` 么？我这有个关于它的 RHS 引用。
> 作用域foo：没听说过。
> JS引擎：Hi，`foo`*作用域* 的 外层*作用域*，哦，你是`global*`*作用域*，你知道变量 `b` 么？我这有个关于它的 RHS 引用。
> 作用域global：当然知道它，拿去吧。

由此👆可见，嵌套作用域的查询规则是：*JS引擎* 会从当前作用域出发向作用域询问变量，如果没有找到，会向上一层询问，直到找到，或者到达最外层作用域。

### 建筑的比喻(Building on Metaphors)
扒一张原书的图，方便更好的理解嵌套作用域：
![avatar](./assets/what's_scope_building.png)

上图中👆，我们从这幢楼的最底部(也就是你当前的作用域)进入，随后就在当前这层查询 LHS 或 RHS，如果没找到，你就会坐电梯到上面一层，再继续查找；如果还是没找到，继续上一层，直到你找到它们(LHS 或 RHS)，或者到达顶部(全局作用域)，在这一层中，你还能继续查找，但是无论找没找到，你不能继续往上了！

## 错误(Error)
*LHS* 和 *RHS* 对于最终没有找到后进行报错，它们各自的处理有不同的表现。