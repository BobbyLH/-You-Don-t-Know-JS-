# 回调函数(Callback)
“回调函数” 是JS中异步编程的基础。有很多的JS程序都是以此来实现异步的，比如第一章中的定时器、网络请求等功能的实现。尽管它并非没有缺点，但更高级的抽象API比如 `Promise`，也是基于它来实现的。如果你不理解它，那就没办法有效的使用在它基础上建立的其他抽象工具。

## 续集(Continuations)
简单的回顾下第一章的 ajax 网络请求：

```js
// A
ajax('…', function () {
  // C
});
// B
```

👆 `// A` 和 `// B` 是程序执行的前半部分，`// C` 是后半部分 —— 前者会立即执行，而后者则要等待一段不确定的时间后，在未来的某个时刻，才会被执行。

换句话说，回调函数封装了一段程序的 *“续集”*。

再来一段更简单的：

```js
// A
setTimeout(function () {
  // C
}, 1000);
// B
```

👆如果让你用大白话把这段代码的执行描述出来，你也许会这么想：“先完成A，而后执行一个要等待1000毫秒的定时器，接下去完成B，而后等到1000毫秒之后，完成C”。

觉着差不多吧？但实际上不够准确。而这些差异正是我们理解 回调函数在表达和管理异步编程的*缺陷* 的核心所在。一旦我们以回调函数的形式引入了多个异步，我们的大脑就不够用了 —— 它的工作方式和代码的执行方式产生了巨大的分歧，而这会使得我的的代码变得难以理解、调试和维护。

## 大脑的顺序(Sequential Brain)
别以为你有一个 “多线程” 的大脑，我们的注意力是有限的。抛开无意识、潜意识、条件反射等功能(心跳、呼吸、眼跳)，我们的大脑是一个一次只能执行单一任务的“机器”。所有你认为你能同时并行处理好几个任务的幻觉，其实都是你大脑在快速的切换它的“上下文”，让你产生你能多任务处理的错觉 —— 这是否听上去有点像JS中是实现异步的事件循环机制呢？如果不是的话，建议回头再看看第一章的内容。

### 做比较(Doing Versus Planing)
我们写代码的时候，会仔细的按照计划的顺序来书写一组要执行的操作(A -> B -> C)，当我们逐条语句书写出同步执行的代码时，它和我们的 todo-list 就很类似：

```js
// 将 x 和 y 的值交换，并用 z 作为保存数据的临时变量
z = x;
x = y;
y = z;
```

👆它们的执行过程一定是一个接一个的执行，很符合我们大脑的计划工作模式。


虽然同步代码能够很好的和我们的大脑相互映射，但异步代码就难以做到这一点了。比如，你能想象一下让你的脑中出现了这些乱七八糟的计划安排时，你是什么感受么？：

> 我准备先去一下超市；但是路上接到了一个电话：“有啥事？老妈”；当她开始唠唠叨叨的时候，我准备先查一下超市的GPS定位；当等待查询结果的时候，我把收音机的音量调小了一些，以便于能够更清楚的听到老妈在说什么；这时候突然想起来我的外套忘带了，不过没关系，开车过去应该问题不大；继续和老妈聊着，突然安全带未系的提升声音响了，赶紧系上；“老妈我一直都系好安全带的，放心吧！” 而后GPS工作了，开始出发……

👆这些乱七八糟的计划安排本质上就是我们大脑工作的方式，并且要记住的是，这不是多任务并行处理，而只是快速的上下文切换罢了。

“意识流” 没有一点顺序可言，这也是为什么一旦用这种模式去实现异步代码，就会让它变得难以理解的原因。因为对于大多数的人来讲，标准的思考的方式是一步一步按计划来的，但是回调函数让我们编写的代码脱离了这个模式，变为了同步和异步的意识流模式。而这也是为什么用回调函数来实现的异步有时候会变得如此难以理解 —— 它和我们大脑的工作方式不符。

比你不知道为什么代码挂了还要衰的事情是 —— 你不知道为什么这段代码居然会第一时间执行。Sartre 说："Hell is other people"，程序员们可能会说："Hell is other people's code"，但我更相信："Hell is not understanding my own code"。而这一切的万恶之源就是回调函数。

### 嵌套/链式 回调函数(Nested/Chained Callback)