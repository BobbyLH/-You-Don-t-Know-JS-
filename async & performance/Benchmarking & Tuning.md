# 基准和调优(Benchmarking & Tuning)
本卷的第五章在宏观的程序运行层面，阐述了一些关于 JS 性能优化相关的内容；而本章正好与其相呼应，在微观，即某一行表达式、语句的层面，再来探究下性能优化。

不过在开始之前，需要强调的是，这一章并非是要探索那些几度令开发者着迷的扣细节游戏 —— 到底是 `++a` 还是 `a++` 在某些个 JS 引擎中执行的更快 —— 分析并测试实现某行代码的多个选项，然后得出谁更快的这种收效甚微的结论。而比这更重要的是，明白到底哪些实现，对 JS 的性能来说才是关键，哪些不是，并且很好的区分这两者。

在实现这个目标之前，我们需要先了解一下如何正确可靠的测试 JS 的性能，否则的话，就会有 “成千上万吨” 的误解和神话的洪流，把你冲击得头晕脑胀，不知所向。

## 基准(Benchmarking)
假如现在有个任务是要求在 JS 中测试某一段代码的执行时间，估计大部分的开发者都会这么做：

```js
var start = (new Date()).getTime();

// some code

var end = (new Date()).getTime();

console.log('Duration: ', end - start);
```

有这样的想法和念头不足为奇，但它有多么不靠谱呢？

- 首先，如果结果为 `0`，你可能会以为它执行的时间少于1毫秒，所以才会这样 —— 想多了！很多浏览器都没有精确到毫秒的能力，比如 IE 浏览器只能精确到15毫秒，这也就是说，执行的代码要是少于这个数，只能得到 `0`。

- 而且，无论最终结果是啥，这都是单次的耗时，你不能确保每次执行，都和这个结果一致。比如 JS 引擎或者操作系统在这个时刻干涉了代码的运行，那后续的耗时是否就比这次快呢？

- 再者，如果结果是 `4`，那你就肯定耗费了4毫秒吗？万一在获取 `start` 或者 `end` 的时间戳的时候遇到了延迟的情况呢？

- 更为头疼的是，你根本不知道你特定的代码片段，是否在这个浏览器环境中被优化过，而一旦被放到实际的执行环境中，这些优化就失效了，最终实际的耗时比你测试的要长。

因此，用这样的方法👆🏻，得到的测试数据，对于实际的生产没有任何指导意义。

### 重复(Repetition)
好，那你说写个 loop 来重复100次，最终得出了137毫秒，然后再除以100，得出了单次运行1.37毫秒的结果，这样总可以了吧？

真的可以吗？别被数学耍的小把戏给欺骗了 —— 100次循环迭代，如果有几个异常情况(outliers)，无论是高还是低，都会严重扭曲平均的结果，而后若是你反复使用这个结论作为依据的时候，还会进一步扩大这个偏差。

另一个办法是不固定次数，而是用运行总时间来进行测量 —— 循环遍历你的代码片段，直到到达某个时间节点，而后根据迭代的总次数来推断出单次耗时。可问题是，总时间怎么定呢？倍数于你估计的单个运行时间？

事实上，总时间应该是基于你使用的宿主环境的定时器的精度来决定，这样能够最大限度的避免测量的误差。你使用的计时器精度越差，你就应运行更长的时间。比如之前提到的，对 IE浏览器的15毫秒精度的计时器而言，总时间设置为750毫秒(15*50)就能将不确定性的概率降低到 1% 以下(利用统计学中标准正态分布就能推导出)，如果是1毫秒精度的计时器，50毫秒总时间应该是相同的效果。

当然，仅仅一个样本是不够的，你还需要更多的样本来平滑掉异常的情况，而且你肯定希望知道最差的样本和最好的样本，以及他们之间的差异情况。你肯定得知道这段代码最短的耗时是多少，以及在多大的程度上能够信任它。显然，你还想要结合其他的技术方案，来作比较，而后挑选出最优的方案……

这些仅仅是开始而已，而若是你觉得太麻烦了，能不能省点事，那很遗憾的告诉你 —— "you don't know: proper benchmarking."

### Benchmark.js
统计学是讨论基准所必备的基础知识，如果你对 “标准差”、“方差”、“误差范围”、“置信区间”…… 这些术语感到陌生，不妨回顾下大学本科时的统计学，曾经教授过的这些基本概念。

当然，伟大的社区早已经有人贡献了方便趁手的工具，就叫 [Benchmark.js](http://benchmarkjs.com/)，所以直接拿来用没啥不好的：

```js
function foo () {
	// some code
}

var bench = new Benchmark(
	'foo test',
	foo,
	{
		// ...     // options
	}
);

bench.hz; // 每秒执行代码的数量
bench.stats.mean; // 算数平均数
bench.stats.moe; // 误差范围
bench.stats.variance; // 样本方差
bench.stats.deviation; // 样本标准差
```

毫不夸张的讲，Benchmark.js 是任何一个初次踏入JS代码的性能基准测试领域的开发者，都应该去尝试使用的一个库，👆🏻上面的示例仅仅是这个库的冰山一角，而诸如比较两个单独的代码块 X 和 Y 到底谁更快时，Benchmark.js 提供了一个叫做 "Suite" 的结构，你能够直接运行它们，而后就能拿到哪个更快的数据了。

无论是在浏览器还是在 Node.js 环境中，Benchmark.js 都提供了良好的支持。

另一个值得花时间考虑的方向是 性能回归测试 领域，就如同单元测试一样，在你的项目中书写好性能测试的用例，而后每次在项目部署前，都自动运行性能测试，以此达到自动监控本次提交的代码，是否对项目的性能造成了影响。

### Setup/Teardown
在初始化 Benchmark.js 的时候，第三个参数能够传递一些可选的配置项，其中有两个选项值得花时间讨论一番：`setup` 和 `teardown`。

Benchmark.js 的文档中是这么描述这两个选项的：
- `setup`: compiled/called before the test loop

- `teardown`: compiled/called after the test loop

这两个选项定义了在你测试代码运行之前，或者运行结束后的回调函数。但是要明白，它们不会在每次迭代的过程中都执行，而只会开始或者结束的时候，执行一次。

强调这一点是因为在某些涉及到 DOM 的测试中，比如往某个元素中追加子元素的操作，此时若是在 `setup` 或者 `teardown` 中有重置父元素的动作是无效的，而最终的结果是会导致DOM元素累积的越来越多，最终让测试的数据和实际的数据产生严重的背离。

## 注意上下文环境(Context Is King)
一个容易被忽视的地方：如果测试的结果是 X 比 Y 快，那么就一定能说 X 比 Y 快么？这仅仅是实验室的数据，别忘记你真实运行代码的时候，都是在一套独特的上下文环境中进行的 —— 比如在用户的某个版本的操作系统下的某个浏览器中。

而且，就算是 X 每秒能运行 10,000,000 次，而 Y 每秒“只能”运行 8,000,000 次 —— 当然从数学角度来讲，Y 比 X 慢 20% 是没有问题的。可是在现实中的确如此吗？

倒推一下不难发现，10,000,000 次每秒 就是 10,000 次每毫秒，再往下就是 10 次每微秒。换句话说，每一次 X 的执行只花了 0.1 微秒 或 100纳秒 —— 一般情况下，人们能够察觉的时间周期是 100毫秒 —— 从这个角度来看，别说 20%，哪怕 99% 的优势都显得毫无意义可言。

就算最新的科学报告说人类大脑的处理速度最快能到 13毫秒，可 X 运行一次的速度依然是这个数值的12.5万倍，而至于 X 和 Y 之间的差距，除非有百万甚至千万次连续的循环运行，否则大脑也根本感知不到差距。

说这么多，其实就是为了破除一种常见的迷思：纠结 “到底是 `++x` 还是 `x++` 更快” 这些细微的差别 —— 先不说能不能知道，就算得出结论，有用吗？

### 引擎的优化(Engine Optimizations)
“X 比 Y 快 10微秒” —— 这样的差距，什么都不是。

例如，对下面的一些 “微观层面的行为” 进行的测试比较(纯理论)：
```js
var twelve = "12";
var foo = "foo";

// 测试 1
var X1 = parseInt(twelve);
var X2 = parseInt(foo);

// 测试 2
var Y1 = Number(twelve);
var Y2 = Number(foo);
// 
```

或许你的直觉会认为 `parseInt(…)` 比 `Number(…)` 做的事情更多，因此更慢；又或许你的直觉告诉你，当参数是 `foo` 的时候，它们做的工作应该都一样 —— 碰到第一个是英文字母 `f` 就应该直接得出结论。

哪一种直觉更准确？或者说它们谁快谁慢真的重要吗？

假如，我们最后从统计学角度得到的答案是 X 和 Y 一样快，那就能说明关于字母 `f` 的直觉是正确的吗？

从理论上讲，一种可能的情况是 JS引擎 对这些操作都做了优化，比如强制将字符串的 `"12"` 转化成数字 `12`；又比如这些测试用例的变量，因为外币对其没有任何引用，所以干脆触发了 `dead-code` 机制，导致的结果是 JS引擎 根本就不会运行这些测试代码……

现代浏览器的 JS引擎 有很多优化的策略，而且很可能同一个浏览器不同的版本，优化的策略都不一样。同样的代码，很可能测试的时候触发了优化策略，而在实际运行的时候却没有，反之亦然。

因此，这种微观层面的比较，对于实际运行的代码，没有任何指导的意义。

但这并不意味着性能的测试都是无意义的。归根结底的问题在于，你没有用实际运行的代码去测试，所以结果也不能反映真实的情况。

所以诸如 `++x` 和 `x++` 的比较，毫无疑问是虚假且无意义的。

### 合理的测试(Sanity Check)
有一些看上去很合理，但实际上很荒谬的测试用例：

```js
// 用例 1
var x = [];
for (var i = 0; i < 10; i++) {
	x[i] = "x";
}

// 用例 2
var x = [];
for (var i = 0; i < 10; i++) {
	x[x.length] = "x";
}

// 用例 3
var x = [];
for (var i = 0; i < 10; i++) {
	x.push("x");
}
```

一些值得我们揣摩的地方：
- `for` 循环完全没有必要，因为 Benchmark.js 已经帮我们实现了这些需要重复的工作；

- 除非你有意要研究 JS引擎 在小数组下的表现，否则一开始的声明以及初始化 `x` 毫无必要，因为有 `setup` 可供使用；

- 测试用例的主旨是比较 `x[x.length]` 和 `x.push(…)` 相对于 `x[i]` 的影响，但显然 `push(…)` 是一个函数调用，毫无疑问会比 `[…]` 访问来得慢。这即意味着 用例1和用例2 一定比 用例3 更快。

下面是另一个常见的无效测试：

```js
// 用例 1
var x = ["John", "Albert", "Sue", "Frank", "Bob"];
x.sort();

// 用例 2
var x = ["John", "Albert", "Sue", "Frank", "Bob"];
x.sort(function mySort(a,b){
	if (a < b) return -1;
	if (a > b) return 1;
	return 0;
});
```

显然👆🏻想要比较的是 `sort()` 内置的比较函数和自定义的函数之间的差距。但依然，这样的测试显得很不公平，因为 用例2 不仅要测试函数本身的性能，还要加上每次声明新函数的开销。正确的做法是在外部定义好函数，而后直接引用即可。

继续用上面的例子看另一个无效的测试：

```js
// 用例 1
var x = [12, -14, 0, 3, 18, 0, 2.9];
x.sort();

// 用例 2
var x = [12, -14, 0, 3, 18, 0, 2.9];
x.sort(function mySort(a,b){
	return a - b;
});
```

除了之前提到的新建函数的开销之外，这个测试用例另一个无效的地方是 `sort(…)` 内置的函数显然比自定义的函数做的事情更多 —— 它会将数字隐式转换成字符串，而后在进行字母表的比较。用例1的结果是 `[-14, 0, 0, 12, 18, 2.9, 3]`，而用例2则为 `[-14, 0, 0, 2.9, 3, 12, 18]`。

另一个更微妙的陷阱：

```js
// 用例 1
var x = false;
var y = x ? 1 : 2;

// 用例 2
var x;
var y = x ? 1 : 2;
```

显然这两个测试的想比较是，三元操作符 `? :` 在判断 `x` 的时候，若是它一个非布尔值(Boolean)，是否做隐式转换。

乍一看好像没啥问题，可是你再仔细看看思考下？

`var x = false;` 和 `var x;` —— 前者可是多了一步赋值的操作啊？！

挺微妙的哈，那么，更精确的测试用例应该这么写：

```js
// 用例 1
var x = false;
var y = x ? 1 : 2;

// 用例 2
var x = undefined;
var y = x ? 1 : 2;
```

现在大家都有赋值过程了，所以得控制好每一个影响因素，才能得出更为精确的结论。

## 如何写出好的测试用例(Writing Good Tests)
简单来讲，就四点：

1. 区分两个测试用例之间的差异，是故意的，还是无意的；如果是前者，那没毛病。如果是后者，那你就要当心是否会影响到测试的结果；

2. 注释和文档，已经是老生常谈了，写性能的测试用例，同样少不了 —— 不仅为了其他人，更是为了未来的你自己；

3. 所有和测试无关的变量声明、函数声明，都挪到外面去；

4. 包含一整块上下文的代码，和只有其中一小部分使用的代码，毫无疑问，前者更适合用来做测试。

## 微观的性能(Microperformance)
在微观层面做性能优化，很多时候都是毫无意义的，核心的原因在于你根本不知道在实际执行过程中，JS引擎是否按照你书写的顺序，不折不扣且逐字逐句的执行 —— 这是必须得习惯的地方，想想之前提到的编译器对语句的重新排序，你就知道你的代码绝非能按照固定的顺序执行，甚至都不能保证执行的代码能完完全全一模一样……

比如：

```js
var foo = 41;
(function () {
	(function () {
		(function (baz) {
			var bar = foo + baz;
			// ……
		})(1);
	})();
})();
```

三层嵌套的 IIFE 可能会让你头晕，而你也许会认为JS引擎找到变量 `foo` 的引用，也需要往外找三层 —— 即便是在，我们之前在讲关于 [作用域和闭包](https://github.com/BobbyLH/ReadingNotes---You-Dont-Know-JS/blob/master/scope%20%26%20closures/lexical.md) 的时候，了解到编译器通常会缓存查找到的引用，因此不会有太多额外的开销的情况下。

但不妨做个思想实验，如果你是编译器的开发者，当你看到 `foo` 完全没被别的地方引用，而且之后也没有任何的赋值操作，把它写死不好吗：

```js
(function () {
	(function () {
		(function (baz) {
			var bar = 41 + baz;
			// ……
		})(1);
	})();
})();
```

同样的，变量 `baz` 也适用于这样的优化措施，不是么？

当你开始思考 **你的代码不是让 JS引擎 逐字逐句去执行，而是告诉且暗示 JS引擎 改怎么做时**，你就会发现之前很多关于 “毫无干系的句法的细枝末节” 的沉迷，都是毫无根据的。

另一个例子是著名的 “阶乘” 的实现：

```js
function factorial(n) {
	if (n < 2) return 1;
	return n * factorial(n - 1);
}

factorial(5); // 120
```

当你还在纠结到底用 `n * factorial(n--)` 还是 `n * factorial(--n)` 来做优化的时候，说不定你的 JS引擎 已经把源码变成了：

```js
function factorial(n) {
	if (n < 2) return 1;
	
	var res = 1;
	for (var i = n; i > 1; i--) {
		res *= i;
	}
	return res;
}

factorial(5); // 120
```

这是江湖传闻 *递归铺平(unrolling recursion)* 的一种实现，显然用循环的方式实现的 “阶乘” 在内存空间上更占优势。并且有一种传闻，最终编译成 C 的时候，`factorial(5)` 会被直接替换成 `120` —— 干脆连函数和函数调用直接一并干掉了……

顺便提一句，说到 `--`，`--n` 和 `n--` 谁更优，显然从理论上讲，`--n` 在处理的更少。

但是，这些都意义不大，与其花心思去琢磨到底该用谁，不如把这些都交给 JS引擎 去考虑，你只要保证你源码的整洁性和可读性就好：

```js
// 选项 1
for (var i = 0; i < 10; i++) {
	console.log(i);
}

// 选项 2
for (var i = 0; i < 10; ++i) {
	console.log(i);
}

// 选项 3
for (var i = -1; ++i < 10;) {
	console.log(i);
}
```

三个最基本的 `for`循环，当你考虑说第二个或者第三个应该比第一个更快的时候，不妨问问自己，第三个是不是容易造成疑惑？那么，即便用了第一个，当 JS引擎 认为可以安全的使用 `++i` 的时候，它自然会这么做的 —— 而不是浪费你大把的时间在这些毫无意义的比较上。

另一个沉迷于微观性能比较的例子：

```js
var x = [...];

// 选项 1
for (var i = 0; i < x.length; i++) {
	// ……
}

// 选项 2
for (var i = 0, len = x.length; i < len; i++) {
	// ……
}
```

有一种理论是说，在循环的时候把数组 `length` 的值缓存下来，而不是每次都去执行计算，能提高性能……

想啥呢！自己看看 [这篇文章](http://mrale.ph/blog/2014/12/24/array-length-caching.html)，在 v8 中，这种理论根据有啥用？别以为自己会比 JS引擎 更“聪明” —— 至少在性能优化这一项，你很可能会输。

### 并非所有的引擎都一样(Not All Engines Are Alike)
任何浏览器都能以不同的方式来处理代码 —— 即便如此，最终也能 “符合规范” —— 当然除了 “尾递归优化(Tail Call Optimization)” 之外。

任何 JS引擎 都能自由的决定，某段代码是否达到了它做优化的阈值，因此想要找出一个 “打遍天下无敌手” 的优化方案几乎是不可能的事情。

当然，在社区内有一种说法，如果你的JS代码运行在服务端，那就可以针对 v8 引擎做特定的优化，这是一项被视为“低成本高收益”的事情。并且还总结一套优化策略：

- 别在函数里使用 `arguments`，这可能会导致严重的内存泄漏；

- 最好将 `try…catch` 放到函数内部(node7.x 已经对这个问题进行了优化)，但问题是很多浏览器对 `try…catch` 做了优化…

很有趣，这些来源是一篇叫做 [优化杀手 Opimization-killers](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments) 的文章所述，并且里面有很多在当时看上去不错的优化点，在 Nodejs 不断迭代的过程中，都逐渐失效了。而且文章现在一开头就提及：

> Please do not take anything written here as performance advice, this is here for historical reasons.

想想也对，除了 Nodejs 本身版本更新迭代的改变之外，`Deno` 目前也能运行在服务器中，你的代码所针对 Nodejs 在某个版本做的优化，说不定现在看来反倒成了逆优化……

有个关于字符串拼接优化的案例，或许能更好的说明这一切：

1. 直接用 `+` 来拼接字符串

2. 将要拼接的字符串放到数组里，而后调用 `join(…)` 方法做拼接

👆🏻这两种方法在某些个浏览器，比如 IE6、IE7 啥的，因为涉及到对字符串在内存中的管理机制，后者的确要比前者快，不过绝大多数现代的浏览器早已没有这个问题，并且针对字符串作做了大量的优化，导致的结果是前者比后者更快。

这时候认真思考下，倘若为了适配某些老旧的浏览器，而采用了方案2，这是真的在做优化吗？

另一个例子是关于 Opera 浏览器的，它曾经的某个版本对于 打包/解包 原始值，和别的浏览器行为不一致。比如你若是想调用字符串对象的某个方法或者属性，比如 `length` 或 `charAt(…)`，你就必须用 `String` 对象来创建这个字符串。而大多数主流的浏览器对于原始值的字符串做了很多优化，但是对于其另外一面 `String`，优化寥寥……

"There is nothing more permanent than a temporary hack" —— 当然这是一句玩笑话，不过也反映了一个普遍存在的现象 —— 你为了适配某个性能问题做的优化，很可能比这个性能问题存在的更久。

当你发现了某个浏览器有性能问题时，向这些浏览器开发团队报告问题，而不是采用 “杀敌一千自损八百” 的办法去解决，是更好的方式。

### 大局观(Big Picture)
与其在细枝末节上纠结，在优化方面我们更应该关注在大局上。

何为“大局观”？首先你得明白，你要优化的这块代码，是否运行在关键路径(critical path)之上。

许多开发者都借用 Donald Knuth 说过的：“过早的优化是一切罪恶的来源(premature optimization is the root of all evil)”，来“挖苦”那些所谓的 “过早(premature)” 的优化。

但其实，[Knuth 完整的话](http://web.archive.org/web/20130731202547/http://pplab.snu.ac.kr/courses/adv_pl05/papers/p261-knuth.pdf)是：

> …… We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that **critical** 3%.

换句话说：“非关键路径上的一切优化才是万恶之源(non-critical path optimization is the root of all evil)”。

关键路径的代码：会多次重复执行的“热”代码、用户会注意到的和 UX 相关的部分，譬如动画循环、CSS 的样式更新等等

比如，一个关键路径上的动画循环，有一段代码是强制将字符串转化成数字：

```js
var x = "42";

var y = x / 2; // 隐式转换

var y = parseInt(x, 0) / 2;

var y = Number(x) / 2;

var y = +x / 2;

var y = (x | 0) / 2;
```

👆🏻上面的几种方式之中，`parseInt(…)` 做的事最多，显然是最慢的，但前提是你不用处理 `var x = '42px';` 这样的字符串的时候。

而 `Number(x)` 虽然和 `+x` 的最终结果一致，但涉及到函数调用，势必需要消耗更多的资源，选择 `+x` 会更快一丢丢。

那么 `+x` 和 `(x | 0)` 是否有必要再去纠结呢？

除了考虑性能之外，代码的易读性和可维护性也是很重要的一环，有时候甚至超过了性能的考量。与其纠结这么一点点的性能差异，而要承受易读性的降低，显然是不划算的。

## 尾调用优化(Tail Call Optimization TCO)
ES6 中规定了一个涉及性能领域的具体要求，即在发生在函数调用时的，尾调用优化(TCO)。

所谓 “尾调用”，就是指函数在调用时，处于另一个函数内部的结尾处，即这个函数的调用是另一个函数调用栈里的最后一步(除了将其 return 之外)：

```js
function foo (x) {
	return x;
}

function bar (y) {
	return foo(y + 1);
}

function baz () {
	return 1 + bar(40);
}

baz();
```

👆🏻 `foo(y+1)` 就是在函数 `bar(…)` 调用中除了 `return` 之外的最后一步，这就是尾调用。相反，`bar(40)` 并非是尾调用，因为在调用完之后，还需要进行加法运算 `1 + …`。

为何尾调用能做优化，这就要涉及到在每个函数调用的时候，系统会为每一个函数都分派单独的 “堆栈帧(stack frame)” —— 这就是额外的内存消耗。因此在没有 TCO 的情况下，`foo(…)`、`bar(…)`、`baz(…)` 都会有各自独立的堆栈帧。

TCO 做的就是，当 `bar(…)` 中的 `foo(y + 1)` 被调用时，并不会再创建一个额外的堆栈帧，而是会复用 `bar` 的堆栈帧。这不仅更快，而且更节省资源。

TCO对于普通的函数调用区别不是很大，但在递归调用的时候，若是层级太深，一般都会被限制执行。这是出于避免发生内存爆栈的缘故。但是按照 TCO 的机制，这样的担心就不会存在了，也因此很多之前没办法在 JS 中运行的算法，有了 TCO 都能更快更高效的执行。

比如用 TCO 来实现一个常见的求阶乘的算法：
```js
function factorial(n) {
	function fn (n, res) {
		if (n < 2) return res;
		return fn(n - 1, n * res);
	}
	return fn(n, 1);
}

factorial(5);
```

按照ES6的规范，只有当函数满足尾调用时，才会实现优化。否则就会降级到传统的函数调用堆栈分配机制。

不过可惜的是，从规范出来到今日，已经过去了五年多的时间，目前绝大部分的浏览器都还没支持 TCO，主要的原因是在执行流中，调用栈的信息丢失，会影响debug的过程。在加上正确的尾调用比较难以实现，目前浏览器是否默认支持 TCO 依旧在讨论中。

## 回顾(Review)
想要有效的测试某块代码片段的性能，特别是几个不同选项之间挑选出最高效的那个，需要仔细注意每个细节。

但是与其自己完成一个统计学上成立的基准逻辑，使用现成 Benchmark.js 的工具库显然是更好的选择。但一定要注意一些微小的差异，失之毫厘谬以千里，它们会严重的扭曲最终的结果。

要避免硬件/设备的之间的差异，应从尽可能多的不同环境中，获得尽可能多的测试结果。使用 jsPerf.com —— 一个使用众包的性能基准测试网站，是不错的选择。

那些微观细节上的性能对比，如 `x++` 与 `++x` 谁快，就是在浪费生命。想要编写一个好的测试，关注大局的思想必不可少。譬如，在关键路径上进行优化，并且避免纠结于不同 JS引擎 的实现细节上的差异。

尾调用优化(TCO)，是ES6的关键的优化项，它能使一些基于递归模式的算法，在JS中实现。TCO 允许在一个函数的尾部，调用另一个函数，这个尾部调用的函数不需要任何额外的资源，这意味着 JS引擎 不再需要对函数调用栈的深度，进行任何限制。