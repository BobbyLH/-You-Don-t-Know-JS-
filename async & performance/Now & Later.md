# 异步：现在 & 未来(Asynchronv: Now & Later)
异步编程在 JS 中是个绕不开的话题，如何使用在整个程序的生命周期中合理的使用它，是一个非常重要但同时也会导致很多误区的地方。

**异步** 说的不是 `for` 循环中从开始到结束所花费的几微秒或者几毫秒，它指的是你的一部分程序在当前运行，而另一部分程序则会在未来某个确定或者不确定的时间中运行 —— 而且在这两块程序中，还有一段时间是你的程序不会运行的 *沟(gap)*。

无论是 *用户的输入*、*从文件系统或数据库中读取数据*、*网络请求* 亦或 *定时不间断的执行某个动画*……这些都要求你的程序能够很好的组织和管理这些跨越 *沟* 的状态，就如同伦敦地铁站里的那句提示一样："mind the gap"。

**现在和未来的关系管理，是异步编程的核心所在**。

在 ES6 之前，JS 中异步的实现只能通过 *回调函数(callback)* 来实现，虽然到今天还是有人认为这已经足够了，但是随着 JS 能够运行在各种浏览器、服务器、客户端，甚至是各种IoT的设备中的时候，异步的管理变得越来越艰难，各种呼吁采取更有力、更合理的异步管理方式不断被提出。

后面的章节中我们会一一探索 JS 中各种异步编程的技术，但在这之前，我们要回归本质，理解到底什么是异步。

## 一个程序块(A Program in Chunks)
哪怕你的 JS 脚本程序只有一个文件，但你的程序在大多数情况下都会有几个 *代码块(chunk)* 组成 —— 只有一个代码块是当前立即执行的，而其余的代码块在未来的某个时间执行。而组织这些代码块最常用的工具就是 `function` 无疑了。

大多数刚开始接触JS的开发者面对 异步 的疑惑，很可能是编写的异步代码没办法立即完成，从而获取到期望的结果：

```js
var data = ajax('http://some.url'); // 假定 ajax 是由某个第三方库提供的异步http请求方法

console.log(data); // data 不是期望的 ajax 返回的值
```

👆直觉上第一时间可能会以为 `data` 会接受到 `ajax` 请求的结果，但要实现这个的前提是 `ajax` 会阻塞后面的代码执行，直到获取到http网络请求的结果，而后进行赋值的动作。但实际上，Ajax 是异步的请求，即在执行了 `ajax(…)` 之后并不会立即返回请求的结果，而是需要提供一个函数，通常情况下这个函数被称为 *回调函数(callback function)*，当网络请求返回结果后，再调用这个函数：

```js
ajax('http://some.url', function callback (data) {
  console.log(data); // 正确获取到网络请求的数据
});
```

**Note**：即便是你能够让 Ajax 的网络请求变成同步代码也尽量别这么做，因为这种阻塞不仅会让浏览器中的 UI 渲染受阻，还会严重的影响用户交互体验，这是可怕的想法，快点把它从脑海中剔除掉！

如果想要避免各种回调函数把自己绕晕，一个不错的办法是让这些包装代码块的函数都有语义清晰名字：

```js
function now () {
  return 21;
}

function later () {
  answer = answer * 2;
  console.log('The answer is: ', answer);
}

var answer = now();

setTimeout(later, 1000);
```

👆上面的代码其实可以看做两块，同步执行的代码块：

```js
function now () {
  return 21;
}

function later () {//……}

var answer = now();

setTimeout(later, 1000);
```

1000毫秒后执行的异步的代码块：
```js
answer = answer * 2;
console.log('The answer is: ', answer);
```

一旦你将某部分代码块放入某个函数中，并将这个函数作为回调函数(比如定时器、事件、Ajax请求)调用时，你其实就使用了异步编程。

### 异步的控制台(Async Console)
针对于 `console.*` 这个宿主环境实现的对象(BOM对象)而言，并没有一个清晰且准确的说明或者文档来定义它到底如何工作 —— 因此不同的JS执行的宿主环境，要如何实现这个功能，真的是随他们的便了(as the please)。

在某些浏览器中的某些条件下，你可能会惊奇的发现 `console.log(…)` 居然不会立即执行，并输出你期望的结果。导致这个现象的主要原因是 I/O 操作是一件非常耗时且会阻塞程序运行的操作(不仅仅JS如此)。因此，出于对性能的考虑，浏览器将 `console.log(…)` 这种 I/O 实现为异步的也没什么好奇怪的。

比如👇：

```js
var a = { index: 1 };
console.log(a);
a.index++;
```

若是将这些代码一股脑的贴到浏览器的控制台中，而后在某些浏览器下，打印出的内容很可能会让你大吃一惊 —— 展开对象 `a` 发现其中的属性 `index` 居然是 `2`。

大多数时候 `console.log(…)` 输出的结果都和我们预期的一致(比如输出的是一个基本数据类型)，不过有时候当浏览器认为你的代码需要被推迟在执行的时候，就如这个例子中输出的是一个对象的时候，当你兴致勃勃想要查看某个对象，从而debug的时候，突然发现这个结果居然已经被修改了……

**Note**：选用 *打断点(breakpoints)* 而不是用 `console.log(…)` 来 debug，因为后者某时候会不太靠谱。如果非得用 `console.log(…)`，记得把你要输出的对象先 “截个图(snapshot)”，比如用 `JSON.stringify(…)` 将其序列化，而后靠谱的输出结果。

## 事件循环(Event Loop)