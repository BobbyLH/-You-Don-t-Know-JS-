# 异步：现在 & 未来(Asynchronv: Now & Later)
异步编程在 JS 中是个绕不开的话题，如何使用在整个程序的生命周期中合理的使用它，是一个非常重要但同时也会导致很多误区的地方。

**异步** 说的不是 `for` 循环中从开始到结束所花费的几微秒或者几毫秒，它指的是你的一部分程序在当前运行，而另一部分程序则会在未来某个确定或者不确定的时间中运行 —— 而且在这两块程序中，还有一段时间是你的程序不会运行的 *沟(gap)*。

无论是 *用户的输入*、*从文件系统或数据库中读取数据*、*网络请求* 亦或 *定时不间断的执行某个动画*……这些都要求你的程序能够很好的组织和管理这些跨越 *沟* 的状态，就如同伦敦地铁站里的那句提示一样："mind the gap"。

**现在和未来的关系管理，是异步编程的核心所在**。

在 ES6 之前，JS 中异步的实现只能通过 *回调函数(callback)* 来实现，虽然到今天还是有人认为这已经足够了，但是随着 JS 能够运行在各种浏览器、服务器、客户端，甚至是各种IoT的设备中的时候，异步的管理变得越来越艰难，各种呼吁采取更有力、更合理的异步管理方式不断被提出。

后面的章节中我们会一一探索 JS 中各种异步编程的技术，但在这之前，我们要回归本质，理解到底什么是异步。

## 一个程序块(A Program in Chunks)
哪怕你的 JS 脚本程序只有一个文件，但你的程序在大多数情况下都会有几个 *代码块(chunk)* 组成 —— 只有一个代码块是当前立即执行的，而其余的代码块在未来的某个时间执行。而组织这些代码块最常用的工具就是 `function` 无疑了。

大多数刚开始接触JS的开发者面对 异步 的疑惑，很可能是编写的异步代码没办法立即完成，从而获取到期望的结果：

```js
var data = ajax('http://some.url'); // 假定 ajax 是由某个第三方库提供的异步http请求方法

console.log(data); // data 不是期望的 ajax 返回的值
```

👆直觉上第一时间可能会以为 `data` 会接受到 `ajax` 请求的结果，但要实现这个的前提是 `ajax` 会阻塞后面的代码执行，直到获取到http网络请求的结果，而后进行赋值的动作。但实际上，Ajax 是异步的请求，即在执行了 `ajax(…)` 之后并不会立即返回请求的结果，而是需要提供一个函数，通常情况下这个函数被称为 *回调函数(callback function)*，当网络请求返回结果后，再调用这个函数：

```js
ajax('http://some.url', function callback (data) {
  console.log(data); // 正确获取到网络请求的数据
});
```

**Note**：即便是你能够让 Ajax 的网络请求变成同步代码也尽量别这么做，因为这种阻塞不仅会让浏览器中的 UI 渲染受阻，还会严重的影响用户交互体验，这是可怕的想法，快点把它从脑海中剔除掉！

如果想要避免各种回调函数把自己绕晕，一个不错的办法是让这些包装代码块的函数都有语义清晰名字：

```js
function now () {
  return 21;
}

function later () {
  answer = answer * 2;
  console.log('The answer is: ', answer);
}

var answer = now();

setTimeout(later, 1000);
```

👆上面的代码其实可以看做两块，同步执行的代码块：

```js
function now () {
  return 21;
}

function later () {//……}

var answer = now();

setTimeout(later, 1000);
```

1000毫秒后执行的异步的代码块：
```js
answer = answer * 2;
console.log('The answer is: ', answer);
```

一旦你将某部分代码块放入某个函数中，并将这个函数作为回调函数(比如定时器、事件、Ajax请求)调用时，你其实就使用了异步编程。

### 异步的控制台(Async Console)
针对于 `console.*` 这个宿主环境实现的对象(BOM对象)而言，并没有一个清晰且准确的说明或者文档来定义它到底如何工作 —— 因此不同的JS执行的宿主环境，要如何实现这个功能，真的是随他们的便了(as the please)。

在某些浏览器中的某些条件下，你可能会惊奇的发现 `console.log(…)` 居然不会立即执行，并输出你期望的结果。导致这个现象的主要原因是 I/O 操作是一件非常耗时且会阻塞程序运行的操作(不仅仅JS如此)。因此，出于对性能的考虑，浏览器将 `console.log(…)` 这种 I/O 实现为异步的也没什么好奇怪的。

比如👇：

```js
var a = { index: 1 };
console.log(a);
a.index++;
```

若是将这些代码一股脑的贴到浏览器的控制台中，而后在某些浏览器下，打印出的内容很可能会让你大吃一惊 —— 展开对象 `a` 发现其中的属性 `index` 居然是 `2`。

大多数时候 `console.log(…)` 输出的结果都和我们预期的一致(比如输出的是一个基本数据类型)，不过有时候当浏览器认为你的代码需要被推迟在执行的时候，就如这个例子中输出的是一个对象的时候，当你兴致勃勃想要查看某个对象，从而debug的时候，突然发现这个结果居然已经被修改了……

**Note**：选用 *打断点(breakpoints)* 而不是用 `console.log(…)` 来 debug，因为后者某时候会不太靠谱。如果非得用 `console.log(…)`，记得把你要输出的对象先 “截个图(snapshot)”，比如用 `JSON.stringify(…)` 将其序列化，而后靠谱的输出结果。

## 事件循环(Event Loop)
尽管异步的代码在JS中随处可见，但直到 ES6 之前，Javascript 都没有一个内置的异步实现。JS 引擎本质上只会在 “被要求(when asked to)” 的时候执行单个的代码块。而 “被谁要求？” —— 这才是关键。

JS 引擎通常情况下并不能单独的运行，它需要搭配一套宿主环境才能运行，对大多数开发者来讲，它一般是浏览器。但随着最近这些年的发展，JS 已经能够运行通过比如 Node.js，运行在服务器上，甚至还被植入到各种各样的设备中，从机器人到电灯泡……

在所有的这些环境中运行的多个代码块，都是通过一个线程完成的，而处理这些代码块的机制被称为 “事件循环(event loop)”。

换句话讲，JS引擎本身对时间并不怎么敏感，它本质上只是按需执行宿主环境中交派给它的JS代码块，宿主环境的工作则是计划和安排 “事件”。

例如，当你想要程序执行一个网络请求从某个服务器获取数据的时候，你通常会设置一段代码置于某个函数中，此时JS引擎通知宿主环境这个函数是需要等到网络请求完毕，获取到数据后再调用的，而宿主环境(浏览器)则会监听网络请求的响应，一旦有数据回来，它就会将这个函数执行插入到事件循环中。

一段简单的伪代码有助于你理解 “事件循环”：

```js
var eventLoop= []; // 事件队列，满足先进先出
var event;

while(true) {
  // tick
  if (eventLoop.length > 0) {
    event = eventLoop.shift();
    // 执行事件
    try {
      event();
    } catch (err) {
      reportError(err);
    }
  }
}
```

👆我们假设 “事件循环” 是运行在一个无限循环的 `while` 循环体中，每次迭代则被称为 “tick”，每一次 tick 都会检查事件队列中是否有排队等候的事件(如同你定义的回调函数)，若是有，则按照先进先出的原则，一个个的执行这些事件。

需要强调的是，`setTimeout(…)` 并不会立马将你的传入的回调函数放入到事件队列中，而是先设置一个计时器，当计时器到点了，才会让宿主环境将你的回调函数加入到事件循环中，而后未来的某一次 tick 将会获取并执行这个回调函数。如果前面已经有排队的事件，你的回调函数必须等到这些事件都执行完毕，才轮到你 —— 没有办法能够插队。这也解释了为什么 `setTimeout(…)` 计时器可能不会精确的按照你设定的时间执行，只能保证说一定不会早于设定的时间，但执行的时间取决于事件队列的状态。

从这个角度来看，你的程序本质上被切分成一个个的小块，一些小块会在另一些小块执行完成之后才会执行。从技术上来看，其他一些和你程序不相干的事件，也可能通过事件队列和你的程序交错执行。

**Note**：ES6中明确的规定了 “事件循环” 应该如何工作，这也意味着以后 “事件循环” 应该属于 JS引擎的范畴，而不是宿主环境。而带来这些改变的源头是ES6中引入的 Promises 机制，它要求能够有更细的颗粒度对事件循环进行控制，第三节会详细讨论。

## 平行线程(Parallel Threading)
